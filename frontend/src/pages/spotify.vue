<template>
    <f7-page id="spotify" infinite-scroll @infinite="searchTracks(offset,true,5)" data-distance="100" >
        <f7-navbar>
          <f7-nav-left back-link="Back" sliding></f7-nav-left>
          <f7-nav-center sliding>Spotify</f7-nav-center>
        </f7-navbar>
         <div v-if="true === loggedIn" class="center">
          <h2> Vorschläge an spotify songs für die aktuelle Laune '{{currentMood}}/{{search}}' </h2>
            <div>
              <f7-list tracks >
              <f7-list-group >
              <f7-list-item v-for="track in tracks">
                <spotifyiframe ref="spotifyIframes" v-bind:src="('https://embed.spotify.com/?uri='+track.uri+'&theme=white&view=coverart')" ></spotifyiframe>
              </f7-list-item>
              </f7-list-group>
            </f7-list>
            </div>
        </div>
        <div v-if="false === loggedIn" class="center">
          <h2>
            Bitte logge dich mit Spotify ein, um Vorschläge basierend auf deiner aktuellen Laune zu erhalten.
          </h2>
          <f7-button class="btn btn-primary" title="Login with Spotify" v-on:click="loginSpotify()" >Login</f7-button>
        </div>
  </f7-page>
</template>

<script>
import Mixins from '../mixins.js'
import SpotifyWebApi from 'spotify-web-api-js';
import Cookie from '../js/Cookie.js'
import Config from '../js/Config.js'
import axios from 'axios'
import Spotifyiframe from '../components/spotifyiframe'
// create a constant to access the functionality
let spotifyWebApi = new SpotifyWebApi();

export default {
  name: 'spotify',
  mixins: [Mixins],
  components: {
    Spotifyiframe
  },
  data: function(){
      return {
         search: '',
         currentMood: '',
         tracks: [],
         prev: undefined,
         offset: 0,
         addingTracks: false,
         loggedIn : false
      }
  },
  mounted: function () {

      window.addEventListener("resize", () => {
        this.respondify();
      });

      var spotifyAccessToken = Cookie.getCookie('spotifyAccessToken');
      if(spotifyAccessToken){
        spotifyWebApi.setAccessToken(spotifyAccessToken);
        this.loggedIn = true;
        this.getCurrentMood();
      } else{
        this.loggedIn = false;
      }
      this.togglePreloaderVisibility();
  },
  methods:{
    /**
     * Requests the current mood of the value from the backend.
     * First the local accessToken has to be checked to send a valid request
     */
    getCurrentMood: function(){
      this.checkAccessToken(this.getCurrentMoodHandler);
    },
    /**
     * Callback handler which will be called if a valid local accessToken exists at a cookie.
     * This function sends the request to the backend and handles the response.
     * @param  {JSONObject} accessToken A JSON object containing the accessToken and a authentication type,
     *                                  required by the backend for each user specific request
     */
    getCurrentMoodHandler: function(accessToken){

      axios.post(Config.webServiceURL + '/getCurrentMood', accessToken)
      .then(response => {
        this.checkServerResponse(response, this.getMoodResponseHandler);
      })
      .catch(function(error){
        console.log("Error: "+JSON.stringify(error));
        // error log to console with description
      });
    },
    /**
     * This function is used to process the response of the backend, after requesting the current mood of the user.
     * After receiving the current mood a search request will be send to spotify to get the songs based on this mood
     * @param  {JSONObject} payload Payload of the data package sent by the backend
     */
    getMoodResponseHandler: function(payload){
      this.search = payload.emotion
      this.currentMood = payload.emotion_de
      this.searchTracks(0,false,10)
    },
    /**
     * Toggles the visibility of the preloader which is generated by the infinite scroll template from framework7.
     * The visibility depends on the spotify loggin status. If the user hasn't logged into spotify, then the preloader is not visible.
     * Otherwise the preloader is visible.
     * @return {[type]} [description]
     */
    togglePreloaderVisibility: function(){
      var preloader = document.getElementsByClassName("infinite-scroll-preloader")[0];
      if(true === this.loggedIn){
        preloader.style.visibility = 'visible';
      } else{
        preloader.style.visibility = 'hidden';
      }
    },
    /**
     * Callback function to be called if the spotify iframes need to be resized
     */
    respondify: function () {
      if(undefined !== this.$refs.spotifyIframes){
        this.$refs.spotifyIframes.forEach(function(item) {
          var w = item.$el.parentNode.offsetWidth;
          item.$el.style.width = w+"px";
        });
      }
    },
    /**
     * Callback function to be called after the user has successfully logged into spotify.
     * The current accessToken is saved into a cookie. Afterwards the accessToken is handed to the spotify web api.
     * Finally the current mood of the user is requested and the corresponding tracks will be loaded.
     * @param  {String} accessToken AccessToken received from the 'spotifyRedirect.html', which is called after a successful spotify login
     *                              The accessToken is then sent via CORS to this page
     */
    loginHandler: function(accessToken){
      Cookie.createCookie("spotifyAccessToken", accessToken);
      this.loggedIn = true;
      this.togglePreloaderVisibility();
      spotifyWebApi.setAccessToken(accessToken);
      this.getCurrentMood();
      console.log("Setting spotify accessToken: "+ accessToken);
    },
    /**
     * Function to be called when the user wants to login into spotify.
     */
    loginSpotify: function(){
      this.login(this.loginHandler);
    },
    /**
     * This callback function is called after the user wants to login into spotify.
     * For authentication a new window will be opened.
     * The resulting authentication request will be send to spotify.
     * After a successful authentication the user will be redirected to 'spotifyRedirect.html'.
     * Also an event message listener is registered, so CORS messages can be received.
     * @param  {Function} callback Callback function to be called after the CORS message containing the accessToken from spotify, sent by 'spotifyRedirect.html' has been received
     */
    login: function(callback) {
        var CLIENT_ID = Config.spotifyClientId;
        var REDIRECT_URI = Config.origin+'spotifyRedirect.html';
        function getLoginURL(scopes) {
            return 'https://accounts.spotify.com/authorize?client_id=' + CLIENT_ID +
              '&redirect_uri=' + encodeURIComponent(REDIRECT_URI) +
              '&scope=' + encodeURIComponent(scopes.join(' ')) +
              '&response_type=token';
        }

        var url = getLoginURL([
            'user-read-email'
        ]);

        var width = 450,
            height = 730,
            left = (screen.width / 2) - (width / 2),
            top = (screen.height / 2) - (height / 2);

        window.addEventListener("message", function(event) {
            console.log("received Message");
            var hash = JSON.parse(event.data);
            if (hash.type == 'access_token') {
                callback(hash.access_token);
            }
        }, false);

        var w = window.open(url,
                            'Spotify',
                            'menubar=no,location=no,resizable=no,scrollbars=no,status=no, width=' + width + ', height=' + height + ', top=' + top + ', left=' + left
                           );

    },
    /**
     * Callback function to be called after the search request has been send to spotify.
     * This function adds or sets the data received by the spotify response into or to an array
     * @param  {JSONObject} data Response data from spotify containing the tracks
     */
    setData: function(data){
      // clean the promise so it doesn't call abort
      this.prev = undefined;
      if(true === this.addingTracks){
        this.tracks = this.tracks.concat(data.tracks.items.slice());
      } else{
        this.tracks = data.tracks.items.slice();
      }
      this.offset = this.tracks.length;
    },
    /**
     * Function to be called to execute a spotify search request.
     * @param  {Number} offset       Number to specify the amount of tracks to be skipped
     * @param  {Boolean} addingTracks Flag to indicate whether the tracks from the spotify response shall be added or set equal to the local array variable
     *                                If this flag is set to false, the local array will be set equal to the tracks from the spotify response
     * @param  {Number} limit        Number to specify the amount of tracks which are requested
     */
    searchTracks: function(offset, addingTracks, limit){
      // abort previous request, if any
      if (undefined !== this.prev && undefined !== this.prev.abort) {
        this.prev.abort();
      }
      this.addingTracks = addingTracks;
      this.prev = spotifyWebApi.searchTracks(this.search, {"offset": offset, "limit": limit})
      .then((response)=>{
        this.setData(response)
      }, function(err) {
        console.error(err);
      });

    }
  }
}
</script>
